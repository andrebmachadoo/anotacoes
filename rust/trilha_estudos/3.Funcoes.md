## FunÃ§Ãµes
---

```rust

// FunÃ§Ã£o simples sem parÃ¢metros e sem retorno
fn saudacao() {
    println!("OlÃ¡, mundo!");
}

// FunÃ§Ã£o com parÃ¢metros e retorno explÃ­cito
fn soma(a: i32, b: i32) -> i32 {
    a + b // sem ponto e vÃ­rgula: valor retornado implicitamente
}

// FunÃ§Ã£o com retorno explÃ­cito e com ponto e vÃ­rgula (precisa do return)
fn multiplicar(a: i32, b: i32) -> i32 {
    return a * b;
}

// FunÃ§Ã£o com tipos primitivos e diferentes
fn exibir_dados(nome: &str, idade: u32) {
    println!("Nome: {}, Idade: {}", nome, idade);
}

// FunÃ§Ã£o que retorna mÃºltiplos valores usando tupla
fn calcular(x: i32, y: i32) -> (i32, i32) {
    let soma = x + y;
    let produto = x * y;
    (soma, produto)
}

// Chamando as funÃ§Ãµes
fn main() {
    saudacao();

    let resultado = soma(10, 5);
    println!("Soma: {}", resultado);

    let mult = multiplicar(3, 4);
    println!("MultiplicaÃ§Ã£o: {}", mult);

    exibir_dados("Ana", 30);

    let (s, p) = calcular(2, 5);
    println!("Soma: {}, Produto: {}", s, p);
}

```

> **ObservaÃ§Ãµes:**  
> - O retorno em Rust pode ser implÃ­cito (sem return e sem ponto e vÃ­rgula) ou explÃ­cito com return.  
> - FunÃ§Ãµes podem retornar tuplas, structs ou qualquer tipo.  
> - ParÃ¢metros podem ser referÃªncias (&str, &T) ou valores diretos (i32, String, etc.).

>Em Rust, alÃ©m das funÃ§Ãµes tradicionais, existem funÃ§Ãµes anÃ´nimas, tambÃ©m chamadas de closures â€” muito parecidas com lambdas em outras linguagens.

**Closures (FunÃ§Ãµes AnÃ´nimas)** 

Closures sÃ£o funÃ§Ãµes sem nome, que podem capturar variÃ¡veis do escopo em que estÃ£o definidas.  
Elas sÃ£o muito usadas para passar lÃ³gica como argumento, especialmente em mÃ©todos como .map(), .filter(), etc.

```rust
let soma = |a: i32, b: i32| -> i32 {
    a + b
};

println!("Resultado: {}", soma(2, 3)); // Resultado: 5

```


**ðŸ§  Capturando variÃ¡veis do escopo**

```rust
let fator = 10;

let multiplicar = |x: i32| x * fator;

println!("Multiplicado: {}", multiplicar(3)); // 30
```

>A closure captura fator do escopo externo, sem precisar passÃ¡-lo como argumento.



**âœ‚ï¸ Closures simples com inferÃªncia de tipo**
> Rust permite omitir tipos quando possÃ­vel:

```rust 
let saudacao = || println!("OlÃ¡!");
saudacao();
```

**ðŸ§ª Usando closures com .iter().map()**


```rust
let numeros = vec![1, 2, 3];
let dobrados: Vec<i32> = numeros.iter().map(|x| x * 2).collect();

println!("{:?}", dobrados); // [2, 4, 6]
```


**ðŸ’¡ ObservaÃ§Ãµes**

 - Closures podem inferir tipos automaticamente.
 - Podem ser armazenadas em variÃ¡veis, passadas como argumentos e retornadas.
 - Por padrÃ£o, elas capturam variÃ¡veis por referÃªncia (&), mutÃ¡vel (&mut) ou por valor (move), dependendo da necessidade.


**1ï¸âƒ£ Usando move em closures**

> O modificador move forÃ§a a closure a capturar variÃ¡veis por valor, ou seja, ela toma a posse (ownership) da variÃ¡vel do escopo externo.

```rust
fn main() {
    let nome = String::from("Ana");

    let imprimir = move || {
        // Aqui a closure toma posse de `nome`
        println!("OlÃ¡, {}", nome);
    };

    imprimir();

    // println!("{}", nome); // âŒ Erro: nome foi movido para a closure
}
```

**Use move quando:**

 - A closure vai viver alÃ©m do escopo atual
 - Precisa mover a variÃ¡vel para outro thread ou estrutura assÃ­ncrona



**2ï¸âƒ£ Passando closures como parÃ¢metro**

> VocÃª pode aceitar closures como parÃ¢metros de funÃ§Ã£o usando traits:

Fn â†’ para leitura

FnMut â†’ se for modificar

FnOnce â†’ se for consumir

âœ… Exemplo com Fn

```rust 
fn executar_duas_vezes<F>(funcao: F)
where
    F: Fn(),
{
    funcao();
    funcao();
}

fn main() {
    let mensagem = "Executando...";

    executar_duas_vezes(|| {
        println!("{}", mensagem);
    });
}
```
**âœ… Exemplo com FnMut**
```rust
fn aplicar_em_lista<F>(lista: &mut Vec<i32>, mut func: F)
where
    F: FnMut(&mut i32),
{
    for item in lista {
        func(item);
    }
}

fn main() {
    let mut numeros = vec![1, 2, 3];

    aplicar_em_lista(&mut numeros, |x| {
        *x *= 2;
    });

    println!("{:?}", numeros); // [2, 4, 6]
}
```

**âœ… Exemplo com FnOnce**

```rust 

fn consumir_uma_vez<F>(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let nome = String::from("Rust");

    consumir_uma_vez(move || {
        println!("Consumido: {}", nome);
    });

    // println!("{}", nome); // âŒ nome foi movido
}

```

**Exemplos prÃ¡ticos de closures com move, FnOnce, FnMut, Fn aplicados em:**


**ðŸ§± 1. Em Structs (armazenar closures)**  
>Para armazenar closures em structs, vocÃª precisa usar Box<dyn Fn...> (trait object), pois closures tÃªm tipos Ãºnicos.

âœ… Exemplo com Fn em uma struct
```rust
struct Bot {
    acao: Box<dyn Fn(&str)>,
}

impl Bot {
    fn responder(&self, nome: &str) {
        (self.acao)(nome);
    }
}

fn main() {
    let bot = Bot {
        acao: Box::new(|nome| {
            println!("OlÃ¡, {}!", nome);
        }),
    };

    bot.responder("Andre");
}
```
>Aqui, usamos Box<dyn Fn> para armazenar a closure no heap e permitir chamadas dinÃ¢micas.

**ðŸ§µ 2. Em Threads com move**  
>Ao usar thread::spawn, a closure deve ser move, pois a thread pode viver mais que o escopo atual.

**âœ… Exemplo com thread::spawn**
```rust 
use std::thread;

fn main() {
    let nome = String::from("Andre");

    let handle = thread::spawn(move || {
        println!("OlÃ¡ de outra thread, {}!", nome);
    });

    handle.join().unwrap();
}
```
>Sem move, nome nÃ£o seria acessÃ­vel na thread porque o escopo principal poderia encerrar antes.

**âš™ï¸ 3. Em funÃ§Ãµes async com closures**
>Rust async tambÃ©m pode aceitar closures, normalmente combinando com .await e async move.

âœ… Exemplo com async + closure
```rust 
use tokio::time::{sleep, Duration};

async fn executar_async<F>(f: F)
where
    F: FnOnce() + Send + 'static,
{
    f();
}

#[tokio::main]
async fn main() {
    let nome = String::from("Async Rust");

    executar_async(move || {
        println!("Rodando com: {}", nome);
    }).await;

    // await em async blocks com closure
    let tarefa = async move {
        sleep(Duration::from_secs(1)).await;
        println!("Terminou depois de 1 segundo.");
    };

    tarefa.await;
}

```
>Aqui:
> - async move garante que as variÃ¡veis necessÃ¡rias estarÃ£o disponÃ­veis no tempo de execuÃ§Ã£o da future.
> - O FnOnce com Send permite passar para spawn ou outros contextos assÃ­ncronos seguros.

**âœ… ConclusÃ£o RÃ¡pida**

|Contexto|Closure Trait|Necessidade de move?|Motivo| 
|:-|:-|:-|:-|
|Struct	|Fn, FnMut|	Opcional|	Armazenamento em heap|
|Thread	|FnOnce	|Sim	|TransferÃªncia de ownership|
|Async block|	FnOnce|	Sim (em geral)|	Permitir mover para a task|

> Tudo isso pode ser combinado para utilizar com canal (mpsc) ou  para criar um executor de jobs usando closures.
---
