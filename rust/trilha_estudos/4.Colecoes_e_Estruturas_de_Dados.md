## Cole√ß√µes e Estruturas de Dados
---

```rust 
use std::collections::{HashMap, HashSet};

fn main() {
    // Array (tamanho fixo, definido em tempo de compila√ß√£o)
    let numeros: [i32; 3] = [1, 2, 3];

    // Vetor (din√¢mico, pode crescer ou diminuir)
    let mut lista: Vec<i32> = vec![10, 20, 30];
    lista.push(40); // adicionando um item

    // Tupla (estrutura heterog√™nea/mista, tamanho fixo)
    let tupla: (i32, f64, &str) = (42, 3.14, "Rust");
    println!("Tupla: {}, {}, {}", tupla.0, tupla.1, tupla.2);

    // HashMap (estrutura chave-valor)
    let mut mapa: HashMap<&str, i32> = HashMap::new();
    mapa.insert("Ana", 25);
    mapa.insert("Bruno", 30);

    if let Some(idade) = mapa.get("Ana") {
        println!("Ana tem {} anos", idade);
    }

    // HashSet (conjunto de valores √∫nicos)
    let mut conjunto: HashSet<i32> = HashSet::new();
    conjunto.insert(1);
    conjunto.insert(2);
    conjunto.insert(2); // valor duplicado n√£o ser√° adicionado

    println!("Conjunto cont√©m 2? {}", conjunto.contains(&2)); // true

    // Struct personalizada
    struct Produto {
        nome: String,
        preco: f64,
    }

    let item = Produto {
        nome: String::from("Notebook"),
        preco: 3499.99,
    };

    println!("Produto: {}, R${}", item.nome, item.preco);

    // Struct com m√©todo (impl)
    impl Produto {
        fn mostrar(&self) {
            println!("{} custa R${}", self.nome, self.preco);
        }
    }

    item.mostrar();
}

```

**‚úÖ O que esse bloco cobre:**

- Arrays e Vetores ([T; N] e Vec<T>)
- Tuplas
- HashMap e HashSet da lib padr√£o (std::collections)
- Structs com campos e m√©todos


### Quatro conceitos s√£o fundamentais em Rust 


**üß± 1. Structs Aninhadas**
```rust 
struct Endereco {
    rua: String,
    numero: u32,
}

struct Pessoa {
    nome: String,
    endereco: Endereco,
}

fn main() {
    let pessoa = Pessoa {
        nome: String::from("Ana"),
        endereco: Endereco {
            rua: String::from("Rua Central"),
            numero: 42,
        },
    };

    println!(
        "{} mora na {}, n¬∫ {}",
        pessoa.nome, pessoa.endereco.rua, pessoa.endereco.numero
    );
}

```

**üé≠ 2. Enum com match**

```rust 
enum Status {
    Online,
    Offline,
    Ausente(String),
}

fn mostrar_status(status: Status) {
    match status {
        Status::Online => println!("Usu√°rio est√° online"),
        Status::Offline => println!("Usu√°rio est√° offline"),
        Status::Ausente(motivo) => println!("Ausente: {}", motivo),
    }
}

fn main() {
    mostrar_status(Status::Online);
    mostrar_status(Status::Ausente(String::from("Almo√ßo")));
}

```
>üìå Enums com dados s√£o poderosos ‚Äî substituem switch-case de forma mais segura.


**‚ùì 3. Option ‚Äì Valor pode estar presente ou n√£o**
```rust
fn buscar_usuario(id: u32) -> Option<&'static str> {
    if id == 1 {
        Some("Ana")
    } else {
        None
    }
}

fn main() {
    let resultado = buscar_usuario(1);

    match resultado {
        Some(nome) => println!("Usu√°rio encontrado: {}", nome),
        None => println!("Usu√°rio n√£o encontrado"),
    }
}

```
>üìå Substitui null de forma segura.
Voc√™ √© obrigado a tratar a possibilidade de aus√™ncia de valor.


**‚ö†Ô∏è 4. Result ‚Äì Sucesso ou Erro**

```rust
fn dividir(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Divis√£o por zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match dividir(10.0, 2.0) {
        Ok(resultado) => println!("Resultado: {}", resultado),
        Err(erro) => println!("Erro: {}", erro),
    }

    match dividir(5.0, 0.0) {
        Ok(_) => {}
        Err(e) => println!("Falha: {}", e),
    }
}

```
> üìå O tipo Result<T, E> obriga voc√™ a lidar com sucesso (Ok) ou falha (Err) de maneira expl√≠cita.


### 4.1 Uso pr√°tico 

**üß± Structs aninhadas**
>Aplica√ß√£o pr√°tica: Representar dados compostos, como Venda contendo uma lista de ItemVenda.
>>Exemplo: Ideal para APIs, banco de dados, serializa√ß√£o JSON (como objetos com atributos filhos).

**üì¶ Tuplas**
>Aplica√ß√£o pr√°tica: Retornar m√∫ltiplos valores de uma fun√ß√£o sem criar uma struct.
>>Exemplo: Uma fun√ß√£o que retorna (dist√¢ncia, tempo) ou (valor, status) rapidamente.

**üîë HashMap**
>Aplica√ß√£o pr√°tica: Armazenar pares chave-valor onde as chaves n√£o se repetem.
>>Exemplo: Contagem de frequ√™ncia de palavras, cache, lookup de configura√ß√µes ou usu√°rios por ID.

**üßÆ HashSet**
> Aplica√ß√£o pr√°tica: Manter uma cole√ß√£o de valores √∫nicos sem repeti√ß√£o.
>> Exemplo: Remover duplicatas de uma lista, verificar se um item j√° foi processado.

**üé≠ Enum com match**
>Aplica√ß√£o pr√°tica: Representar varia√ß√µes de estado com seguran√ßa.
>> Exemplo: Estado de uma conex√£o (Conectado, Desconectado, Erro(String)), eventos de UI (Clique, Tecla(u8), Scroll(i32)).

**‚ùì Option**
>Aplica√ß√£o pr√°tica: Quando um valor pode ou n√£o estar presente (em vez de null).
>> Exemplo: Buscar usu√°rio no banco ‚Äî pode retornar Some(usuario) ou None.

**‚ö†Ô∏è Result**
>Aplica√ß√£o pr√°tica: Representar o sucesso ou falha de uma opera√ß√£o.
>>Exemplo: Leitura de arquivo, opera√ß√£o matem√°tica que pode falhar, conex√£o com servidor.

**‚ùî Option com unwrap_or**
>Aplica√ß√£o pr√°tica: Definir um valor padr√£o caso o Option seja None.
>>Exemplo: Obter nome do usu√°rio ou usar "Convidado" caso n√£o esteja logado.
```rust
let nome = opcional_nome.unwrap_or("Convidado");
```

**üîß Option com map**  
>Aplica√ß√£o pr√°tica: Aplicar transforma√ß√£o s√≥ se o valor existir.
>>Exemplo: Converter Option<&str> para Option<String> sem if ou match.
```rust
let nome_formatado = opcional_nome.map(|n| n.to_uppercase());
```

**‚ùìüÜöüß® match/Result s√£o iguais ao try/catch do JavaScript?** Parcialmente.  

> Diferen√ßas importantes:
- Em Rust, Result com match √© expl√≠cito e seguro em tempo de compila√ß√£o.
- Em JS, try/catch √© din√¢mico e pode capturar qualquer erro inesperado.
- Rust n√£o usa exce√ß√µes como controle de fluxo. Voc√™ lida com o erro no tipo (Result), n√£o com exce√ß√µes lan√ßadas pelo sistema.

> üß† Ou seja: Result + match substituem try/catch, mas com mais seguran√ßa e previsibilidade.

---
