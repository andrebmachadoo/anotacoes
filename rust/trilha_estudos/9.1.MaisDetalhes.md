# Sistema de Módulos Rust: mod.rs e Controle de Escopo

## 1. Conceitos Fundamentais

### 1.1 O que são Módulos?

Em Rust, módulos são a forma de organizar código em namespaces hierárquicos. Eles servem para:
- **Organização**: Estruturar código em unidades lógicas
- **Encapsulamento**: Controlar visibilidade (público/privado)
- **Reutilização**: Criar componentes reutilizáveis
- **Namespace**: Evitar conflitos de nomes

### 1.2 Comparação com JavaScript

**JavaScript (ES6 Modules):**
```javascript
// utils.js
export function calcular(a, b) {
    return a + b;
}

export default class MinhaClasse {
    // implementação
}

// main.js
import MinhaClasse, { calcular } from './utils.js';
```

**Rust (Modules):**
```rust
// utils.rs
pub fn calcular(a: i32, b: i32) -> i32 {
    a + b
}

pub struct MinhaStruct {
    // implementação
}

// main.rs
mod utils;
use utils::{calcular, MinhaStruct};
```

## 2. Estrutura de Arquivos e mod.rs

### 2.1 Evolução do Sistema de Módulos

**Antes do Rust 2018 (Sistema Antigo):**
```
src/
├── main.rs
├── lib.rs
├── utils/
│   ├── mod.rs          # Obrigatório!
│   ├── math.rs
│   └── string.rs
└── database/
    ├── mod.rs          # Obrigatório!
    └── connection.rs
```

**Rust 2018+ (Sistema Atual):**
```
src/
├── main.rs
├── lib.rs
├── utils.rs            # Módulo simples
├── utils/              # OU pasta com submódulos
│   ├── math.rs
│   └── string.rs
└── database.rs         # Módulo simples
```

### 2.2 Quando usar mod.rs

**Ainda é necessário quando:**
1. Você quer um arquivo principal para o módulo
2. Precisa de lógica de inicialização
3. Quer re-exportar itens de submódulos
4. Compatibilidade com Rust pre-2018

### 2.3 Exemplo Prático: Sistema de Arquivos

```
meu_projeto/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── lib.rs
    ├── auth/
    │   ├── mod.rs       # Arquivo principal do módulo auth
    │   ├── login.rs     # Submódulo
    │   └── register.rs  # Submódulo
    ├── database/
    │   ├── mod.rs       # Arquivo principal do módulo database
    │   ├── connection.rs
    │   └── models.rs
    └── utils.rs         # Módulo simples
```

## 3. Implementação Detalhada

### 3.1 Arquivo mod.rs - Exemplo Completo

**src/auth/mod.rs:**
```rust
// Declarar submódulos
mod login;
mod register;

// Re-exportar itens públicos
pub use login::LoginManager;
pub use register::RegisterManager;

// Código próprio do módulo
pub struct AuthConfig {
    pub secret_key: String,
    pub token_expiry: u64,
}

impl AuthConfig {
    pub fn new(secret: String) -> Self {
        Self {
            secret_key: secret,
            token_expiry: 3600,
        }
    }
}

// Função de inicialização do módulo
pub fn initialize_auth() -> AuthConfig {
    AuthConfig::new("my-secret-key".to_string())
}

// Função privada (não é pub)
fn validate_config(config: &AuthConfig) -> bool {
    !config.secret_key.is_empty()
}
```

**src/auth/login.rs:**
```rust
use super::AuthConfig; // Importar do módulo pai

pub struct LoginManager {
    config: AuthConfig,
}

impl LoginManager {
    pub fn new(config: AuthConfig) -> Self {
        Self { config }
    }
    
    pub fn authenticate(&self, username: &str, password: &str) -> bool {
        // Implementação do login
        !username.is_empty() && !password.is_empty()
    }
}

// Função privada - só visível dentro deste arquivo
fn hash_password(password: &str) -> String {
    format!("hashed_{}", password)
}
```

**src/auth/register.rs:**
```rust
use super::AuthConfig;

pub struct RegisterManager {
    config: AuthConfig,
}

impl RegisterManager {
    pub fn new(config: AuthConfig) -> Self {
        Self { config }
    }
    
    pub fn create_user(&self, username: &str, password: &str) -> bool {
        // Implementação do registro
        !username.is_empty() && !password.is_empty()
    }
}
```

### 3.2 Usando o Módulo

**src/main.rs:**
```rust
// Declarar módulo
mod auth;

// Importar itens específicos
use auth::{AuthConfig, LoginManager, RegisterManager, initialize_auth};

// Ou importar tudo
use auth::*;

fn main() {
    // Usar função de inicialização
    let config = initialize_auth();
    
    // Usar structs re-exportados
    let login_manager = LoginManager::new(config);
    let result = login_manager.authenticate("user", "pass");
    
    println!("Login result: {}", result);
}
```

## 4. Controle de Visibilidade

### 4.1 Níveis de Visibilidade

```rust
mod meu_modulo {
    // Privado (padrão) - só visível dentro do módulo
    fn funcao_privada() {}
    
    // Público - visível para quem importar o módulo
    pub fn funcao_publica() {}
    
    // Público para o crate - visível apenas dentro do crate
    pub(crate) fn funcao_crate() {}
    
    // Público para o módulo pai
    pub(super) fn funcao_super() {}
    
    // Público para um módulo específico
    pub(in crate::outro_modulo) fn funcao_especifica() {}
    
    pub struct MinhaStruct {
        pub campo_publico: i32,
        campo_privado: String,          // Privado por padrão
        pub(crate) campo_crate: bool,   // Visível no crate
    }
}
```

### 4.2 Exemplo de Controle de Acesso

**src/database/mod.rs:**
```rust
mod connection;
mod models;

// Re-exportar apenas o que queremos público
pub use connection::DatabaseConnection;
pub use models::User;

// Manter ConnectionPool privado
use connection::ConnectionPool;

pub struct Database {
    pool: ConnectionPool, // Privado
}

impl Database {
    pub fn new() -> Self {
        Self {
            pool: ConnectionPool::new(),
        }
    }
    
    pub fn get_user(&self, id: u32) -> Option<User> {
        // Implementação usando pool privado
        self.pool.execute_query(id)
    }
}
```

**src/database/connection.rs:**
```rust
// Público para o módulo pai
pub(super) struct ConnectionPool {
    connections: Vec<DatabaseConnection>,
}

impl ConnectionPool {
    pub(super) fn new() -> Self {
        Self {
            connections: Vec::new(),
        }
    }
    
    pub(super) fn execute_query(&self, id: u32) -> Option<super::User> {
        // Implementação
        None
    }
}

// Público para qualquer um que importe o módulo database
pub struct DatabaseConnection {
    pub url: String,
}
```

## 5. Padrões Comuns

### 5.1 Padrão Facade

**src/api/mod.rs:**
```rust
// Módulos internos
mod handlers;
mod middleware;
mod routes;

// Re-exportar apenas a interface pública
pub use handlers::ApiHandler;
pub use routes::setup_routes;

// Função de conveniência
pub fn create_api() -> ApiHandler {
    ApiHandler::new()
}
```

### 5.2 Padrão Prelude

**src/prelude.rs:**
```rust
// Re-exportar itens mais usados
pub use crate::auth::{LoginManager, RegisterManager};
pub use crate::database::Database;
pub use crate::utils::*;

// Tipos comuns
pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;
```

**Uso:**
```rust
use meu_crate::prelude::*;

// Agora tem acesso a tudo que é comum
```

### 5.3 Padrão de Inicialização

**src/config/mod.rs:**
```rust
mod database;
mod server;

pub use database::DatabaseConfig;
pub use server::ServerConfig;

pub struct AppConfig {
    pub database: DatabaseConfig,
    pub server: ServerConfig,
}

impl AppConfig {
    pub fn from_env() -> Self {
        Self {
            database: DatabaseConfig::from_env(),
            server: ServerConfig::from_env(),
        }
    }
}

// Função de inicialização global
pub fn initialize() -> AppConfig {
    AppConfig::from_env()
}
```

## 6. Diferenças Entre mod.rs e arquivos normais

### 6.1 Arquivo mod.rs

**Vantagens:**
- Ponto central de controle para o módulo
- Pode ter lógica de inicialização
- Facilita re-exportação
- Permite estruturação hierárquica clara

**Desvantagens:**
- Arquivo extra desnecessário para módulos simples
- Pode criar confusão sobre onde está o código
- Mais verboso para casos simples

### 6.2 Arquivo normal (nome_modulo.rs)

**Vantagens:**
- Mais simples para módulos pequenos
- Menos arquivos para gerenciar
- Padrão mais moderno (Rust 2018+)

**Desvantagens:**
- Não pode ter submódulos facilmente
- Menos controle sobre a estrutura

## 7. Exemplo Completo: Sistema de E-commerce

```
src/
├── main.rs
├── lib.rs
├── models/
│   ├── mod.rs          # Re-exporta User, Product, Order
│   ├── user.rs
│   ├── product.rs
│   └── order.rs
├── services/
│   ├── mod.rs          # Re-exporta UserService, ProductService
│   ├── user_service.rs
│   └── product_service.rs
├── database/
│   ├── mod.rs          # Inicialização e configuração
│   ├── connection.rs
│   └── migrations.rs
├── api/
│   ├── mod.rs          # Setup de rotas
│   ├── handlers.rs
│   └── middleware.rs
└── utils.rs            # Módulo simples
```

**src/models/mod.rs:**
```rust
pub mod user;
pub mod product;
pub mod order;

// Re-exportar structs principais
pub use user::User;
pub use product::Product;
pub use order::Order;

// Trait comum para todos os models
pub trait Model {
    fn id(&self) -> u32;
    fn validate(&self) -> bool;
}
```

**src/services/mod.rs:**
```rust
mod user_service;
mod product_service;

pub use user_service::UserService;
pub use product_service::ProductService;

// Função de inicialização de todos os serviços
pub fn initialize_services() -> (UserService, ProductService) {
    (
        UserService::new(),
        ProductService::new(),
    )
}
```

**src/main.rs:**
```rust
mod models;
mod services;
mod database;
mod api;
mod utils;

use models::{User, Product, Order};
use services::{UserService, ProductService};
use database::Database;

fn main() {
    // Inicializar sistema
    let db = Database::new();
    let (user_service, product_service) = services::initialize_services();
    
    // Usar serviços
    let user = User::new("João".to_string());
    user_service.create_user(user);
}
```

## 8. Melhores Práticas

### 8.1 Quando usar mod.rs

**Use mod.rs quando:**
- Módulo tem submódulos
- Precisa de lógica de inicialização
- Quer controle fino sobre re-exportação
- Tem configurações específicas do módulo

### 8.2 Quando NÃO usar mod.rs

**Use arquivo normal quando:**
- Módulo é simples e pequeno
- Não tem submódulos
- Apenas agrupa funções relacionadas
- Quer simplicidade

### 8.3 Convenções

```rust
// ✅ Bom: nomes descritivos
mod user_authentication;
mod database_connection;

// ❌ Ruim: nomes genéricos
mod utils;
mod helpers;

// ✅ Bom: re-exportação clara
pub use internal_module::PublicStruct;

// ❌ Ruim: expor internos
pub use internal_module::*;
```

## 9. Comparação Final: JS vs Rust

| Aspecto | JavaScript | Rust |
|---------|------------|------|
| **Arquivo de módulo** | qualquer.js | mod.rs ou qualquer.rs |
| **Exportar** | `export` | `pub` |
| **Importar** | `import` | `use` |
| **Padrão** | Público | Privado |
| **Estrutura** | Flexível | Hierárquica |
| **Re-exportação** | `export * from` | `pub use` |
| **Submódulos** | Pastas | `mod` declaration |

**Rust é mais explícito e rígido, mas oferece maior controle sobre visibilidade e organização do código!**