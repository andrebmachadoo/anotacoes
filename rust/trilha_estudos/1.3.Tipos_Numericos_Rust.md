## üìä Tabela: Tipos Num√©ricos em Rust
---

| Tipo    | Faixa de valores aproximada                        | Tamanho (bytes) |
| ------- | -------------------------------------------------- | --------------- |
| `i8`    | -128 a 127                                         | 1 b             |
| `u8`    | 0 a 255                                            | 1 b             |
| `i16`   | -32 mil a 32 mil                                   | 2 b             |
| `u16`   | 0 a 65 mil                                         | 2 b             |
| `i32`   | -2,1 bilh√µes a 2,1 bilh√µes                         | 4 b             |
| `u32`   | 0 a 4,2 bilh√µes                                    | 4 b             |
| `i64`   | ¬±9 quintilh√µes                                     | 8 b             |
| `u64`   | 0 a 18 quintilh√µes                                 | 8 b             |
| `i128`  | ¬±10¬≥‚Å∏ (extremamente grande)                        | 16 b            |
| `u128`  | 0 a 10¬≥‚Å∏                                           | 16 b            |
| `isize` | Depende da arquitetura (32 bits ou 64 bits)        | 4 b ou 8 b      |
| `usize` | Depende da arquitetura (32 bits ou 64 bits)        | 4 b ou 8 b      |
| `f32`   | ¬±3.4 √ó 10¬≥‚Å∏ com \~6-7 d√≠gitos decimais de precis√£o | 4 b             |
| `f64`   | ¬±1.8 √ó 10¬≥‚Å∞‚Å∏ com \~15-16 d√≠gitos decimais          | 8 b             |


**üîç Explicando isize e usize**

| Tipo    | Explica√ß√£o                                                                                                                                                |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `isize` | Inteiro com sinal com o mesmo tamanho da arquitetura do sistema. Ex: 32 bits ‚Üí i32, 64 bits ‚Üí i64. Usado em opera√ß√µes com √≠ndices negativos, como arrays. |
| `usize` | Inteiro sem sinal (s√≥ positivos) com mesmo tamanho da arquitetura. Muito usado para indexar ou contar elementos (como em `.len()` ou `.iter()`).          |


üí∏ Float ou Decimal para valores monet√°rios?

- ‚ùå f32 / f64 (float): N√£o s√£o ideais para valores monet√°rios. Eles usam ponto flutuante bin√°rio, o que pode causar imprecis√£o em valores com casas decimais, como 0.1 + 0.2 ‚â† 0.3 exato.
- ‚úÖ Decimal (ou tipos com precis√£o fixa): S√£o a escolha correta para dinheiro, pois mant√™m precis√£o exata em c√°lculos com casas decimais. No Rust, ainda n√£o existe um decimal na stdlib, mas voc√™ pode usar crates como:

```toml

# Cargo.toml
rust_decimal = "1.34"
``` 

```rust
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

let valor = dec!(12.99);
``` 

üìå No MySQL/PostgreSQL: use DECIMAL(10,2) ou NUMERIC(10,2) para valores monet√°rios.


**‚úÖ O sqlx j√° gerencia DECIMAL do banco?**

>Sim!
>O sqlx consegue mapear automaticamente colunas do tipo DECIMAL, NUMERIC, etc., para o tipo rust_decimal::Decimal ‚Äî desde que voc√™ adicione o crate rust_decimal e as features certas.

Exemplo no Cargo.toml:

```toml

# Para usar com sqlx + postgres
rust_decimal = { version = "1.34", features = ["db-postgres"] }

# Para usar com MySQL
# rust_decimal = { version = "1.34", features = ["db-mysql"] }
O sqlx vai usar automaticamente Decimal em structs, assim:
```

```rust
use rust_decimal::Decimal;
use sqlx::FromRow;

#[derive(FromRow)]
struct Produto {
    preco: Decimal,
}
```

**‚ùì Posso usar Decimal s√≥ para c√°lculos e depois converter para float para exibir?**

- Pode, mas... com cuidado.
- Voc√™ pode converter Decimal ‚Üí f64 para apresentar:

```rust
let valor_decimal: Decimal = dec!(12.99);
let valor_f64: f64 = valor_decimal.to_f64().unwrap(); // Cuidado com unwrap!
```

**üî∏ Vantagens:**
- Usa Decimal para manter a precis√£o nos c√°lculos monet√°rios.
- Usa f64 s√≥ na apresenta√ß√£o, como em gr√°ficos, UI ou JSON (com .to_string() ou .to_f64()).

üî∏ Desvantagens:
- Pode perder precis√£o na convers√£o para f64, ent√£o n√£o deve converter antes de salvar ou calcular.
- Para APIs, ainda √© melhor enviar como string ("12.99") para evitar erros de ponto flutuante em outras linguagens.

**üü® Conclus√£o pr√°tica**

| Situa√ß√£o                | Melhor tipo em Rust     |
| ----------------------- | ----------------------- |
| C√°lculo monet√°rio       | `rust_decimal::Decimal` |
| Leitura/scrita no banco | `Decimal` com `sqlx`    |
| Exibi√ß√£o na tela ou UI  | `f64` ou `String`       |
| API (JSON)              | Enviar como `String`    |












