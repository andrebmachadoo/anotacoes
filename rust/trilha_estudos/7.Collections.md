## Collections (cole√ß√µes) principais tipos de cole√ß√µes
---

**üì¶ 1. Tuplas (Tuples)**   
>√öteis para agrupar valores de tipos diferentes:
```rust
let pessoa: (&str, u32) = ("Ana", 30);
println!("Nome: {}, Idade: {}", pessoa.0, pessoa.1);
```
**üì¶ 2. Vetores (Vec<T>)**
>Cole√ß√£o din√¢mica ‚Äî pode crescer ou diminuir:
```rust
let mut numeros: Vec<i32> = vec![1, 2, 3];
numeros.push(4);
for n in &numeros {
    println!("N√∫mero: {}", n);
}
```

**üì¶ 3. Arrays ([T; N])**  
>Tamanho fixo, conhecido em tempo de compila√ß√£o:
```rust
let dias: [&str; 3] = ["Seg", "Ter", "Qua"];
println!("Primeiro dia: {}", dias[0]);
```

**üì¶ 4. HashMap (mapa de chave-valor)**  
>Equivalente a objetos em JS, dicion√°rios em Python:
```rust
use std::collections::HashMap;

let mut estoque = HashMap::new();
estoque.insert("Caneta", 10);
estoque.insert("Caderno", 5);

if let Some(qtd) = estoque.get("Caneta") {
    println!("Temos {} canetas!", qtd);
}
```

**üì¶ 5. HashSet (conjunto de valores √∫nicos)**  
>Sem duplicatas, √∫til para verificar presen√ßa:
```rust
use std::collections::HashSet;

let mut nomes = HashSet::new();
nomes.insert("Ana");
nomes.insert("Ana"); // Ignorado

println!("Total: {}", nomes.len()); // 1
```
---
**Principais m√©todos (ou fun√ß√µes associadas) dispon√≠veis em tuplas, arrays, vetores (Vec), HashMap e HashSet no Rust. Foco em fun√ß√µes mais semelhantes ao JavaScript:**

| Tipo       | M√©todo ou fun√ß√£o       | Para que serve                                             |                   |                                                                          |
| ---------- | ---------------------- | ---------------------------------------------------------- | ----------------- | ------------------------------------------------------------------------ |
| **Vec<T>** | `push(valor)`          | Adiciona um item ao final do vetor (como `push()` em JS)   |                   |                                                                          |
|            | `pop()`                | Remove e retorna o √∫ltimo elemento (como `pop()` em JS)    |                   |                                                                          |
|            | `remove(index)`        | Remove item em um √≠ndice espec√≠fico                        |                   |                                                                          |
|            | `insert(index, valor)` | Insere um valor na posi√ß√£o informada                       |                   |                                                                          |
|            | `len()`                | Retorna o tamanho do vetor                                 |                   |                                                                          |
|            | `is_empty()`           | Verifica se o vetor est√° vazio                             |                   |                                                                          |
|            | `contains(&valor)`     | Verifica se o valor existe no vetor                        |                   |                                                                          |
|            | `iter()`               | Cria um iterador imut√°vel (usado com `map`, `filter`, etc) |                   |                                                                          |
|            | `iter_mut()`           | Iterador mut√°vel                                           |                   |                                                                          |
|            | `into_iter()`          | Consome o vetor e retorna um iterador                      |                   |                                                                          |
|            | `retain()`             | Remove itens que **n√£o** atendem ao crit√©rio (como `filter` com remo√ß√£o)|       |                                                                          |   
|            | `map()`                | (via iter) | Transforma itens (como `map()` em JS)         |                   |                                                                          |   
|            | `filter()`             | Filtra valores com base numa condi√ß√£o                      |                   |                                                                          |   
|            | `clone()`              | Clona o vetor                                              |                   |                                                                          |


| Tipo                | M√©todo ou fun√ß√£o | Para que serve                         |
| ------------------- | ---------------- | -------------------------------------- |
| **\[T; N]** (array) | `.len()`         | Retorna o tamanho                      |
|                     | `.iter()`        | Itera sobre os elementos               |
|                     | `.to_vec()`      | Converte o array fixo para um `Vec<T>` |

| Tipo      | M√©todo ou fun√ß√£o       | Para que serve                            |
| --------- | ---------------------- | ----------------------------------------- |
| **Tupla** | `.0`, `.1`, ...        | Acessa os elementos da tupla              |
|           | `destructuring`        | Atribui√ß√£o m√∫ltipla: `let (a, b) = tupla` |
|           | `.into()` / `.clone()` | Copia ou converte (se aplic√°vel)          |

| Tipo        | M√©todo ou fun√ß√£o       | Para que serve                                         |
| ----------- | ---------------------- | ------------------------------------------------------ |
| **HashMap** | `insert(chave, valor)` | Adiciona ou substitui um valor por chave               |
|             | `get(&chave)`          | Acessa um valor por chave (`Option`)                   |
|             | `remove(&chave)`       | Remove um item pela chave                              |
|             | `contains_key(&chave)` | Verifica se uma chave existe                           |
|             | `len()`                | Retorna a quantidade de pares                          |
|             | `is_empty()`           | Verifica se o mapa est√° vazio                          |
|             | `keys()` / `values()`  | Iteradores sobre chaves ou valores                     |
|             | `entry()`              | Acesso ou inser√ß√£o condicional (`entry().or_insert()`) |
|             | `iter()`               | Iterador de `(chave, valor)`                           |


| Tipo        | M√©todo ou fun√ß√£o       | Para que serve                  |
| ----------- | ---------------------- | ------------------------------- |
| **HashSet** | `insert(valor)`        | Adiciona um valor √∫nico         |
|             | `contains(&valor)`     | Verifica se o valor existe      |
|             | `remove(&valor)`       | Remove um valor                 |
|             | `len()` / `is_empty()` | Tamanho ou vazio                |
|             | `iter()`               | Iterador sobre os itens         |
|             | `intersection(&outro)` | Interse√ß√£o entre dois conjuntos |
|             | `union(&outro)`        | Uni√£o de dois conjuntos         |
|             | `difference(&outro)`   | Diferen√ßa entre dois conjuntos  |


**ü¶Ä Exemplo Rust - Estilo funcional com Vec**
```rust
#[derive(Debug, Clone)]
struct Produto {
    nome: String,
    preco: f64,
    ativo: bool,
}

fn main() {
    let produtos = vec![
        Produto { nome: "Mouse".into(), preco: 80.0, ativo: true },
        Produto { nome: "Teclado".into(), preco: 150.0, ativo: false },
        Produto { nome: "Monitor".into(), preco: 899.0, ativo: true },
    ];

    // ‚úÖ Filtra apenas os produtos ativos
    let ativos: Vec<Produto> = produtos
        .iter() // itera√ß√£o imut√°vel
        .filter(|p| p.ativo)
        .cloned() // necess√°rio para transformar de &Produto para Produto
        .collect();

    // ‚úÖ Aplica um desconto e transforma em nova lista
    let com_desconto: Vec<Produto> = ativos
        .iter()
        .map(|p| Produto {
            preco: p.preco * 0.9,
            ..p.clone()
        })
        .collect();

    // ‚úÖ Exibe os produtos com desconto
    println!("Produtos com desconto:");
    for p in &com_desconto {
        println!("- {} por R${:.2}", p.nome, p.preco);
    }

    // ‚úÖ Modifica vetor original removendo produtos inativos (como filter mut√°vel)
    let mut todos = produtos.clone();
    todos.retain(|p| p.ativo);

    println!("\nAp√≥s remover inativos:");
    for p in &todos {
        println!("- {} est√° ativo", p.nome);
    }
}
```

---
