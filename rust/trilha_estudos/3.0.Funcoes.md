## Funções
---

```rust

// Função simples sem parâmetros e sem retorno
fn saudacao() {
    println!("Olá, mundo!");
}

// Função com parâmetros e retorno explícito
fn soma(a: i32, b: i32) -> i32 {
    a + b // sem ponto e vírgula: valor retornado implicitamente
}

// Função com retorno explícito e com ponto e vírgula (precisa do return)
fn multiplicar(a: i32, b: i32) -> i32 {
    return a * b;
}

// Função com tipos primitivos e diferentes
fn exibir_dados(nome: &str, idade: u32) {
    println!("Nome: {}, Idade: {}", nome, idade);
}

// Função que retorna múltiplos valores usando tupla
fn calcular(x: i32, y: i32) -> (i32, i32) {
    let soma = x + y;
    let produto = x * y;
    (soma, produto)
}

// Chamando as funções
fn main() {
    saudacao();

    let resultado = soma(10, 5);
    println!("Soma: {}", resultado);

    let mult = multiplicar(3, 4);
    println!("Multiplicação: {}", mult);

    exibir_dados("Ana", 30);

    let (s, p) = calcular(2, 5);
    println!("Soma: {}, Produto: {}", s, p);
}

```

> **Observações:**  
> - O retorno em Rust pode ser implícito (sem return e sem ponto e vírgula) ou explícito com return.  
> - Funções podem retornar tuplas, structs ou qualquer tipo.  
> - Parâmetros podem ser referências (&str, &T) ou valores diretos (i32, String, etc.).

>Em Rust, além das funções tradicionais, existem funções anônimas, também chamadas de closures — muito parecidas com lambdas em outras linguagens.

**Closures (Funções Anônimas)** 

Closures são funções sem nome, que podem capturar variáveis do escopo em que estão definidas.  
Elas são muito usadas para passar lógica como argumento, especialmente em métodos como .map(), .filter(), etc.

```rust
let soma = |a: i32, b: i32| -> i32 {
    a + b
};

println!("Resultado: {}", soma(2, 3)); // Resultado: 5

```


**🧠 Capturando variáveis do escopo**

```rust
let fator = 10;

let multiplicar = |x: i32| x * fator;

println!("Multiplicado: {}", multiplicar(3)); // 30
```

>A closure captura fator do escopo externo, sem precisar passá-lo como argumento.



**✂️ Closures simples com inferência de tipo**
> Rust permite omitir tipos quando possível:

```rust 
let saudacao = || println!("Olá!");
saudacao();
```

**🧪 Usando closures com .iter().map()**


```rust
let numeros = vec![1, 2, 3];
let dobrados: Vec<i32> = numeros.iter().map(|x| x * 2).collect();

println!("{:?}", dobrados); // [2, 4, 6]
```


**💡 Observações**

 - Closures podem inferir tipos automaticamente.
 - Podem ser armazenadas em variáveis, passadas como argumentos e retornadas.
 - Por padrão, elas capturam variáveis por referência (&), mutável (&mut) ou por valor (move), dependendo da necessidade.


**1️⃣ Usando move em closures**

> O modificador move força a closure a capturar variáveis por valor, ou seja, ela toma a posse (ownership) da variável do escopo externo.

```rust
fn main() {
    let nome = String::from("Ana");

    let imprimir = move || {
        // Aqui a closure toma posse de `nome`
        println!("Olá, {}", nome);
    };

    imprimir();

    // println!("{}", nome); // ❌ Erro: nome foi movido para a closure
}
```

**Use move quando:**

 - A closure vai viver além do escopo atual
 - Precisa mover a variável para outro thread ou estrutura assíncrona



**2️⃣ Passando closures como parâmetro**

> Você pode aceitar closures como parâmetros de função usando traits:

Fn → para leitura

FnMut → se for modificar

FnOnce → se for consumir

✅ Exemplo com Fn

```rust 
fn executar_duas_vezes<F>(funcao: F)
where
    F: Fn(),
{
    funcao();
    funcao();
}

fn main() {
    let mensagem = "Executando...";

    executar_duas_vezes(|| {
        println!("{}", mensagem);
    });
}
```
**✅ Exemplo com FnMut**
```rust
fn aplicar_em_lista<F>(lista: &mut Vec<i32>, mut func: F)
where
    F: FnMut(&mut i32),
{
    for item in lista {
        func(item);
    }
}

fn main() {
    let mut numeros = vec![1, 2, 3];

    aplicar_em_lista(&mut numeros, |x| {
        *x *= 2;
    });

    println!("{:?}", numeros); // [2, 4, 6]
}
```

**✅ Exemplo com FnOnce**

```rust 

fn consumir_uma_vez<F>(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let nome = String::from("Rust");

    consumir_uma_vez(move || {
        println!("Consumido: {}", nome);
    });

    // println!("{}", nome); // ❌ nome foi movido
}

```

**Exemplos práticos de closures com move, FnOnce, FnMut, Fn aplicados em:**


**🧱 1. Em Structs (armazenar closures)**  
>Para armazenar closures em structs, você precisa usar Box<dyn Fn...> (trait object), pois closures têm tipos únicos.

✅ Exemplo com Fn em uma struct
```rust
struct Bot {
    acao: Box<dyn Fn(&str)>,
}

impl Bot {
    fn responder(&self, nome: &str) {
        (self.acao)(nome);
    }
}

fn main() {
    let bot = Bot {
        acao: Box::new(|nome| {
            println!("Olá, {}!", nome);
        }),
    };

    bot.responder("Andre");
}
```
>Aqui, usamos Box<dyn Fn> para armazenar a closure no heap e permitir chamadas dinâmicas.

**🧵 2. Em Threads com move**  
>Ao usar thread::spawn, a closure deve ser move, pois a thread pode viver mais que o escopo atual.

**✅ Exemplo com thread::spawn**
```rust 
use std::thread;

fn main() {
    let nome = String::from("Andre");

    let handle = thread::spawn(move || {
        println!("Olá de outra thread, {}!", nome);
    });

    handle.join().unwrap();
}
```
>Sem move, nome não seria acessível na thread porque o escopo principal poderia encerrar antes.

**⚙️ 3. Em funções async com closures**
>Rust async também pode aceitar closures, normalmente combinando com .await e async move.

✅ Exemplo com async + closure
```rust 
use tokio::time::{sleep, Duration};

async fn executar_async<F>(f: F)
where
    F: FnOnce() + Send + 'static,
{
    f();
}

#[tokio::main]
async fn main() {
    let nome = String::from("Async Rust");

    executar_async(move || {
        println!("Rodando com: {}", nome);
    }).await;

    // await em async blocks com closure
    let tarefa = async move {
        sleep(Duration::from_secs(1)).await;
        println!("Terminou depois de 1 segundo.");
    };

    tarefa.await;
}

```
>Aqui:
> - async move garante que as variáveis necessárias estarão disponíveis no tempo de execução da future.
> - O FnOnce com Send permite passar para spawn ou outros contextos assíncronos seguros.

**✅ Conclusão Rápida**

|Contexto|Closure Trait|Necessidade de move?|Motivo| 
|:-|:-|:-|:-|
|Struct	|Fn, FnMut|	Opcional|	Armazenamento em heap|
|Thread	|FnOnce	|Sim	|Transferência de ownership|
|Async block|	FnOnce|	Sim (em geral)|	Permitir mover para a task|

> Tudo isso pode ser combinado para utilizar com canal (mpsc) ou  para criar um executor de jobs usando closures.
---
