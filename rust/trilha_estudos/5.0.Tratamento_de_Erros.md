## Tratamento de Erros
---

```rust
use std::fs::File;
use std::io::{self, Read};

fn main() {
    // Tratando erro ao abrir um arquivo
    let resultado = File::open("dados.txt");

    match resultado {
        Ok(mut arquivo) => {
            let mut conteudo = String::new();
            arquivo.read_to_string(&mut conteudo).unwrap();
            println!("Conte√∫do do arquivo:\n{}", conteudo);
        }
        Err(erro) => {
            println!("Erro ao abrir o arquivo: {}", erro);
        }
    }

    // Usando unwrap (s√≥ se tiver certeza que n√£o vai falhar)
    let _arquivo2 = File::open("caminho_certo.txt").unwrap();

    // Usando expect para erro mais descritivo
    let _arquivo3 = File::open("outro.txt").expect("Arquivo n√£o encontrado!");

    // Fun√ß√£o que retorna Result
    match dividir(10.0, 0.0) {
        Ok(resultado) => println!("Divis√£o: {}", resultado),
        Err(msg) => println!("Erro: {}", msg),
    }
}

fn dividir(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Divis√£o por zero"))
    } else {
        Ok(a / b)
    }
}

```

**1Ô∏è‚É£ Como usar o operador ? (propaga√ß√£o de erro)**
> O operador ? propaga automaticamente o erro para quem chamou a fun√ß√£o, simplificando o c√≥digo.  

‚úÖ Exemplo simples com Result
```rust
use std::fs::File;
use std::io::{self, Read};

fn ler_arquivo() -> Result<String, io::Error> {
    let mut arquivo = File::open("dados.txt")?; // se falhar, retorna o erro
    let mut conteudo = String::new();
    arquivo.read_to_string(&mut conteudo)?;     // idem
    Ok(conteudo)
}

fn main() {
    match ler_arquivo() {
        Ok(texto) => println!("Conte√∫do:\n{}", texto),
        Err(e) => println!("Erro ao ler: {}", e),
    }
}
```
> üß† O ? s√≥ pode ser usado em fun√ß√µes que retornam Result ou Option.

**2Ô∏è‚É£ Como combinar Result com Option**  
> √Äs vezes, voc√™ quer tratar duas fontes poss√≠veis de falha:
>* Algo pode dar errado (Result)
>* Ou pode n√£o existir (Option)

‚úÖ Exemplo com Option.ok_or e ?
```rust
fn buscar_usuario(id: u32) -> Result<String, String> {
    let dados: Option<&str> = if id == 1 { Some("Ana") } else { None };

    let nome = dados.ok_or("Usu√°rio n√£o encontrado")?; // transforma Option em Result
    Ok(format!("Usu√°rio encontrado: {}", nome))
}

fn main() {
    match buscar_usuario(2) {
        Ok(msg) => println!("{}", msg),
        Err(e) => println!("Erro: {}", e),
    }
}
```

**3Ô∏è‚É£ Como criar seus pr√≥prios tipos de erro**

> Voc√™ pode definir seus pr√≥prios erros com enum e usar impl std::error::Error.

‚úÖ Exemplo de erro personalizado
```rust
use std::fmt;

#[derive(Debug)]
enum MeuErro {
    DivisaoPorZero,
    NumeroNegativo,
}

// Implementando Display (para printar o erro)
impl fmt::Display for MeuErro {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MeuErro::DivisaoPorZero => write!(f, "N√£o pode dividir por zero"),
            MeuErro::NumeroNegativo => write!(f, "N√∫mero negativo n√£o permitido"),
        }
    }
}

// Fun√ß√£o usando o erro personalizado
fn dividir(a: i32, b: i32) -> Result<i32, MeuErro> {
    if b == 0 {
        Err(MeuErro::DivisaoPorZero)
    } else if a < 0 || b < 0 {
        Err(MeuErro::NumeroNegativo)
    } else {
        Ok(a / b)
    }
}

fn main() {
    match dividir(-10, 2) {
        Ok(r) => println!("Resultado: {}", r),
        Err(e) => println!("Erro: {}", e),
    }
}

```

> **Ha mais possibilidades em tratamento de erros, como:** //TODO::Estudar 
>* Usar ? com m√∫ltiplas fun√ß√µes encadeadas
>* Integrar erros personalizados com bibliotecas externas (Error + From)
>* Usar Result<T, Box<dyn Error>> para retornos gen√©ricos


> Em APIs e sistemas de complexidade m√©dia, o tratamento de erros em Rust costuma seguir alguns padr√µes mais pr√°ticos e seguros. Abaixo explico quais abordagens s√£o mais comuns e por qu√™, em situa√ß√µes t√≠picas como requisi√ß√µes HTTP, JSON e integra√ß√µes externas:

**‚úÖ Tratamentos de erro mais comuns no dia a dia**

**1Ô∏è‚É£ Result<T, E> com ?**

**Situa√ß√£o:** opera√ß√µes que podem falhar, como:
* Leitura de arquivo
* Requisi√ß√µes HTTP
* Deserializa√ß√£o de JSON

```rust
let response = reqwest::get(url).await?.json::<MinhaResposta>().await?;
```
**‚úÖ Motivo:** o ? simplifica o c√≥digo e j√° propaga o erro.
> üîí Bom para fun√ß√µes que j√° retornam Result, como handlers de API.


**2Ô∏è‚É£ Option<T> com ok_or(...) ou ok_or_else(...)**  
**Situa√ß√£o:** Falta de campo em JSON ou valores opcionais.

```rust
let nome = json.get("nome").and_then(|v| v.as_str()).ok_or("Nome ausente")?;
```
**‚úÖ Motivo:** transforma Option em Result com mensagem de erro clara.
> üß† √ötil ao validar dados antes de salvar no banco, por exemplo.



**3Ô∏è‚É£ match em cima de Result ou Option**  
**Situa√ß√£o:** controle de fluxo mais detalhado, logs, fallback.

match resultado {
    Ok(dados) => processar(dados),
    Err(e) => log::warn!("Erro na API: {}", e),
}
> ‚úÖ Motivo: permite resposta customizada, como um HTTP 400 ou 500.

**4Ô∏è‚É£ unwrap_or, unwrap_or_else, map_or, map_or_else**
**Situa√ß√£o:** valores opcionais com padr√£o ou l√≥gica alternativa.

```rust
let idade = json.get("idade").and_then(|v| v.as_u64()).unwrap_or(0);
```
**‚úÖ Motivo:** muito √∫til para JSON parcial ou campos opcionais.
>üß† Use s√≥ quando faz sentido continuar com valor padr√£o.


**5Ô∏è‚É£ thiserror ou anyhow (crates para erros elegantes)**  
**Situa√ß√£o:** projetos m√©dios, com m√∫ltiplas fontes de erro.

```rust
#[derive(thiserror::Error, Debug)]
pub enum MeuErro {
    #[error("Erro na API: {0}")]
    Api(String),
    #[error("Erro de JSON")]
    Json(#[from] serde_json::Error),
}
```
>‚úÖ Motivo: melhora a legibilidade, evita repeti√ß√µes, compat√≠vel com ?.


**üß≠ Dica geral por contexto**

| Contexto                      | Recomendado                                         |
| ----------------------------- | --------------------------------------------------- |
| Falta de campo no JSON        | `Option + ok_or`                                    |
| Erro ao chamar API externa    | `Result + match` ou `?` + enum personalizado        |
| L√≥gica de fallback            | `unwrap_or`, `unwrap_or_else`                       |
| Fun√ß√µes encadeadas            | `?`                                                 |
| Erros variados no mesmo fluxo | `enum + thiserror`                                  |
| Sistemas REST ou GraphQL      | `Result<T, ApiError>` com c√≥digo/status customizado |



**Exemplo pr√°tico completo simulando uma API que:**

- Recebe JSON com campos opcionais
- Valida campos obrigat√≥rios
- Faz uma chamada externa (simulada)
- Usa ?, Option, ok_or, thiserror e retorna um Result

```rust
use serde::Deserialize;
use thiserror::Error;

// Dados recebidos no JSON
#[derive(Deserialize)]
struct PedidoInput {
    cliente: Option<String>,
    produto_id: Option<u32>,
    quantidade: Option<u32>,
}

// Erros poss√≠veis da API
#[derive(Debug, Error)]
enum ApiErro {
    #[error("Campo obrigat√≥rio ausente: {0}")]
    CampoAusente(&'static str),

    #[error("Erro de rede")]
    Rede(#[from] reqwest::Error),

    #[error("Erro inesperado")]
    Outro(String),
}

// Simula√ß√£o de chamada externa (ex: estoque)
async fn verificar_estoque(produto_id: u32) -> Result<bool, reqwest::Error> {
    // Aqui seria: reqwest::get(...).await?.json().await
    Ok(produto_id != 0) // falso se id = 0
}

// Handler da rota POST /pedidos
async fn criar_pedido(body: PedidoInput) -> Result<String, ApiErro> {
    // Valida√ß√µes
    let cliente = body.cliente.ok_or(ApiErro::CampoAusente("cliente"))?;
    let produto_id = body.produto_id.ok_or(ApiErro::CampoAusente("produto_id"))?;
    let quantidade = body.quantidade.unwrap_or(1); // opcional com padr√£o

    // Verifica se produto est√° dispon√≠vel (chamada externa)
    let disponivel = verificar_estoque(produto_id).await?;
    if !disponivel {
        return Err(ApiErro::Outro("Produto sem estoque".to_string()));
    }

    Ok(format!(
        "Pedido criado: cliente={}, produto={}, quantidade={}",
        cliente, produto_id, quantidade
    ))
}

```
---''
