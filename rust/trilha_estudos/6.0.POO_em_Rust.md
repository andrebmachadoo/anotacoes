## Programação Orientada a Objetos em Rust
---

>Rust não tem classes, mas permite usar conceitos similares de POO usando:

- Structs com métodos
- Traits (interfaces)
- Trait Objects (polimorfismo dinâmico)
- Enum + match (para substituir herança em muitos casos)

**🧩 1. Struct com métodos**
```rust
struct Pessoa {
    nome: String,
    idade: u32,
}

impl Pessoa {
    // método "estático"
    fn nova(nome: &str, idade: u32) -> Self {
        Self {
            nome: nome.to_string(),
            idade,
        }
    }

    // método que acessa o self
    fn saudacao(&self) -> String {
        format!("Olá, meu nome é {} e tenho {} anos.", self.nome, self.idade)
    }
}

fn main() {
    let p = Pessoa::nova("Ana", 30);
    println!("{}", p.saudacao());
}

```

**🧬 2. Traits (interfaces)**
```rust
trait Animal {
    fn emitir_som(&self);
}

struct Cachorro;
struct Gato;

impl Animal for Cachorro {
    fn emitir_som(&self) {
        println!("Au au!");
    }
}

impl Animal for Gato {
    fn emitir_som(&self) {
        println!("Miau!");
    }
}

```

**🔁 3. Polimorfismo com trait objects**
```rust
fn fazer_barulho(animal: &dyn Animal) {
    animal.emitir_som();
}

fn main() {
    let cachorro = Cachorro;
    let gato = Gato;

    fazer_barulho(&cachorro);
    fazer_barulho(&gato);
}

```
>💡 **&dyn** Trait é como um interface em outras linguagens — permite passar qualquer tipo que implemente a trait

**❗ 4. Rust não tem herança entre structs**  
>Substitui-se com composição (structs dentro de structs)  
> Ou enum + match para comportamentos variados
```rust
enum Forma {
    Circulo(f64),
    Retangulo(f64, f64),
}

impl Forma {
    fn area(&self) -> f64 {
        match self {
            Forma::Circulo(raio) => std::f64::consts::PI * raio * raio,
            Forma::Retangulo(l, a) => l * a,
        }
    }
}
```


**📌 Quando usar POO em Rust:**
| Situação                                   | Abordagem em Rust              |
| ------------------------------------------ | ------------------------------ |
| Estruturas com métodos                     | `impl`                         |
| Interfaces com múltiplas implementações    | `trait`                        |
| Polimorfismo em tempo de execução          | `&dyn Trait`                   |
| Substituir herança entre classes           | `enum` com `match`, composição |
| Compartilhar lógica entre tipos diferentes | `default impl` ou composição   |

**📌 O que é dyn em Rust?**  
>dyn é uma palavra-chave que indica um trait object — ou seja, uma referência a qualquer tipo que implementa uma trait, mas cujo tipo exato só será conhecido em tempo de execução.

**🧠 Em outras palavras:**  
> - dyn Trait = interface dinâmica  
> - Usado para polimorfismo em tempo de execução   
> - Serve quando vários tipos diferentes implementam a mesma trait, e você quer tratá-los de forma genérica


```rust
trait Crud {
    fn create(&self);
    fn read(&self);
    fn update(&self);
    fn delete(&self);
}

// Modelo Produto
struct Produto {
    nome: String,
    preco: f64,
}

impl Crud for Produto {
    fn create(&self) {
        println!("Criando produto: {}", self.nome);
    }
    fn read(&self) {
        println!("Lendo produto: {} (R${:.2})", self.nome, self.preco);
    }
    fn update(&self) {
        println!("Atualizando produto: {}", self.nome);
    }
    fn delete(&self) {
        println!("Removendo produto: {}", self.nome);
    }
}

// Modelo Cliente
struct Cliente {
    nome: String,
    email: String,
}

impl Crud for Cliente {
    fn create(&self) {
        println!("Criando cliente: {}", self.nome);
    }
    fn read(&self) {
        println!("Lendo cliente: {} ({})", self.nome, self.email);
    }
    fn update(&self) {
        println!("Atualizando cliente: {}", self.nome);
    }
    fn delete(&self) {
        println!("Removendo cliente: {}", self.nome);
    }
}

// Função genérica para aplicar as operações CRUD
fn executar_crud(entidade: &dyn Crud) {
    entidade.create();
    entidade.read();
    entidade.update();
    entidade.delete();
}

fn main() {
    let prod = Produto {
        nome: "Teclado".to_string(),
        preco: 129.99,
    };

    let cli = Cliente {
        nome: "Ana".to_string(),
        email: "ana@example.com".to_string(),
    };

    println!("== Produto ==");
    executar_crud(&prod);

    println!("\n== Cliente ==");
    executar_crud(&cli);
}

```


**💡 Por que dyn é necessário?**  
>Sem dyn, o compilador tentaria saber em tempo de compilação qual é o tipo real. Mas com dyn, dizemos:  
>"confie em mim, o tipo implementa essa trait; descubra qual é só em tempo de execução."

> **Se você tentar usar na função executar_crud() um método não declarado na trait Crud, o Rust vai recusar compilar, mesmo que a struct em si tenha aquele método.** A trait é o contrato mínimo que a função conhece. O tipo real (ex: Produto) pode ter outros métodos, mas eles ficam inacessíveis via dyn Crud.

**⚠️ Importante:**
>Você não pode armazenar tipos diferentes diretamente num Vec<Animal>  
>Mas pode fazer isso com Vec<Box<dyn Animal>>

```rust
let animais: Vec<Box<dyn Animal>> = vec![
    Box::new(Gato),
    Box::new(Cachorro),
];
```

**✅ 2. O que é Box?**  
>Box<T> é um ponteiro inteligente que aloca um valor no heap em vez da stack.  
>**🧠 Para que serve?**
> - Armazenar dados grandes ou de tamanho desconhecido em tempo de compilação
> - Armazenar tipos dinâmicos, como Box<dyn Trait>
> - Mover valores sem copiar
> - Evitar recursão infinita em structs recursivas (como em árvores)


🧪 Exemplo simples:
```rust 

let valor = Box::new(42);      // Aloca 42 no heap
println!("{}", *valor);        // Desreferencia

//Exemplo com Trait, Sem Box:
let lista: Vec<dyn Crud>;  // ❌ ERRO: tamanho desconhecido

//Com Box:

let lista: Vec<Box<dyn Crud>> = vec![
    Box::new(Produto { nome: "X".to_string(), preco: 1.0 }),
    Box::new(Cliente { nome: "Y".to_string(), email: "x@y.com" }),
];

```

> 🧠 Por quê?
dyn Trait tem tamanho indefinido, mas Box<dyn Trait> tem tamanho fixo (um ponteiro) — e isso resolve o problema de armazenamento.

**✅ 1. Comparação com JavaScript:**

> Passar &dyn Trait para uma função em Rust é como passar um objeto com métodos para uma função em JavaScript:
```js
function executar(obj) {
  obj.read();
  obj.update();
}
```
> Em Rust: executar_crud(entidade: &dyn Crud) faz isso com segurança de tipo e desempenho melhor

---
**✅ 2. Diferença entre stack e heap:**  

**Stack:** memória local da thread atual, rápida, com tamanho fixo, usada para dados pequenos e temporários (como números, referências, structs pequenas).

**Heap:** memória globalmente acessível, usada para dados grandes ou de tempo de vida indefinido (como String, Vec, Box, etc).

**Resumindo:**  
**Stack** rápida, local, previsível  
**Heap** → flexível, compartilhável, mais lenta (mas necessária em muitos casos)

**✅ 2. O programador deve se preocupar com stack/heap?**

> Sim, mas com muito menos dor de cabeça.  
> Rust cuida da alocação e liberação automaticamente, mas você deve entender os princípios para escrever código eficiente e sem erros de propriedade.

**✅ Exemplo prático: leitura de JSON (ex: array de objetos)**  

>Quando você lê o retorno de uma API com serde_json e transforma em um Vec<Objeto>, o Rust: 
>Aloca o vetor (Vec) no stack  
>Aloca os dados (cada Objeto) no heap  

**✅ Isso é automático, você não precisa gerenciar manualmente.**

```rust
#[derive(Deserialize)]
struct Produto {
    nome: String,
    preco: f64,
}

let json = r#"[{"nome":"Caneta","preco":2.5}]"#;
let produtos: Vec<Produto> = serde_json::from_str(json)?; // Alocado corretamente
```
> **A String e o Vec são heap por natureza.**  
> A variável produtos (ponteiro + tamanho + capacidade) vive na stack.  
> O conteúdo (cada Produto) vai para o heap.

---

