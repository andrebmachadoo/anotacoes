## ProgramaÃ§Ã£o Orientada a Objetos em Rust
---

>Rust nÃ£o tem classes, mas permite usar conceitos similares de POO usando:

- Structs com mÃ©todos
- Traits (interfaces)
- Trait Objects (polimorfismo dinÃ¢mico)
- Enum + match (para substituir heranÃ§a em muitos casos)

**ğŸ§© 1. Struct com mÃ©todos**
```rust
struct Pessoa {
    nome: String,
    idade: u32,
}

impl Pessoa {
    // mÃ©todo "estÃ¡tico"
    fn nova(nome: &str, idade: u32) -> Self {
        Self {
            nome: nome.to_string(),
            idade,
        }
    }

    // mÃ©todo que acessa o self
    fn saudacao(&self) -> String {
        format!("OlÃ¡, meu nome Ã© {} e tenho {} anos.", self.nome, self.idade)
    }
}

fn main() {
    let p = Pessoa::nova("Ana", 30);
    println!("{}", p.saudacao());
}

```

**ğŸ§¬ 2. Traits (interfaces)**
```rust
trait Animal {
    fn emitir_som(&self);
}

struct Cachorro;
struct Gato;

impl Animal for Cachorro {
    fn emitir_som(&self) {
        println!("Au au!");
    }
}

impl Animal for Gato {
    fn emitir_som(&self) {
        println!("Miau!");
    }
}

```

**ğŸ” 3. Polimorfismo com trait objects**
```rust
fn fazer_barulho(animal: &dyn Animal) {
    animal.emitir_som();
}

fn main() {
    let cachorro = Cachorro;
    let gato = Gato;

    fazer_barulho(&cachorro);
    fazer_barulho(&gato);
}

```
>ğŸ’¡ **&dyn** Trait Ã© como um interface em outras linguagens â€” permite passar qualquer tipo que implemente a trait

**â— 4. Rust nÃ£o tem heranÃ§a entre structs**  
>Substitui-se com composiÃ§Ã£o (structs dentro de structs)  
> Ou enum + match para comportamentos variados
```rust
enum Forma {
    Circulo(f64),
    Retangulo(f64, f64),
}

impl Forma {
    fn area(&self) -> f64 {
        match self {
            Forma::Circulo(raio) => std::f64::consts::PI * raio * raio,
            Forma::Retangulo(l, a) => l * a,
        }
    }
}
```


**ğŸ“Œ Quando usar POO em Rust:**
| SituaÃ§Ã£o                                   | Abordagem em Rust              |
| ------------------------------------------ | ------------------------------ |
| Estruturas com mÃ©todos                     | `impl`                         |
| Interfaces com mÃºltiplas implementaÃ§Ãµes    | `trait`                        |
| Polimorfismo em tempo de execuÃ§Ã£o          | `&dyn Trait`                   |
| Substituir heranÃ§a entre classes           | `enum` com `match`, composiÃ§Ã£o |
| Compartilhar lÃ³gica entre tipos diferentes | `default impl` ou composiÃ§Ã£o   |

**ğŸ“Œ O que Ã© dyn em Rust?**  
>dyn Ã© uma palavra-chave que indica um trait object â€” ou seja, uma referÃªncia a qualquer tipo que implementa uma trait, mas cujo tipo exato sÃ³ serÃ¡ conhecido em tempo de execuÃ§Ã£o.

**ğŸ§  Em outras palavras:**  
> - dyn Trait = interface dinÃ¢mica  
> - Usado para polimorfismo em tempo de execuÃ§Ã£o   
> - Serve quando vÃ¡rios tipos diferentes implementam a mesma trait, e vocÃª quer tratÃ¡-los de forma genÃ©rica


```rust
trait Crud {
    fn create(&self);
    fn read(&self);
    fn update(&self);
    fn delete(&self);
}

// Modelo Produto
struct Produto {
    nome: String,
    preco: f64,
}

impl Crud for Produto {
    fn create(&self) {
        println!("Criando produto: {}", self.nome);
    }
    fn read(&self) {
        println!("Lendo produto: {} (R${:.2})", self.nome, self.preco);
    }
    fn update(&self) {
        println!("Atualizando produto: {}", self.nome);
    }
    fn delete(&self) {
        println!("Removendo produto: {}", self.nome);
    }
}

// Modelo Cliente
struct Cliente {
    nome: String,
    email: String,
}

impl Crud for Cliente {
    fn create(&self) {
        println!("Criando cliente: {}", self.nome);
    }
    fn read(&self) {
        println!("Lendo cliente: {} ({})", self.nome, self.email);
    }
    fn update(&self) {
        println!("Atualizando cliente: {}", self.nome);
    }
    fn delete(&self) {
        println!("Removendo cliente: {}", self.nome);
    }
}

// FunÃ§Ã£o genÃ©rica para aplicar as operaÃ§Ãµes CRUD
fn executar_crud(entidade: &dyn Crud) {
    entidade.create();
    entidade.read();
    entidade.update();
    entidade.delete();
}

fn main() {
    let prod = Produto {
        nome: "Teclado".to_string(),
        preco: 129.99,
    };

    let cli = Cliente {
        nome: "Ana".to_string(),
        email: "ana@example.com".to_string(),
    };

    println!("== Produto ==");
    executar_crud(&prod);

    println!("\n== Cliente ==");
    executar_crud(&cli);
}

```


**ğŸ’¡ Por que dyn Ã© necessÃ¡rio?**  
>Sem dyn, o compilador tentaria saber em tempo de compilaÃ§Ã£o qual Ã© o tipo real. Mas com dyn, dizemos:  
>"confie em mim, o tipo implementa essa trait; descubra qual Ã© sÃ³ em tempo de execuÃ§Ã£o."

> **Se vocÃª tentar usar na funÃ§Ã£o executar_crud() um mÃ©todo nÃ£o declarado na trait Crud, o Rust vai recusar compilar, mesmo que a struct em si tenha aquele mÃ©todo.** A trait Ã© o contrato mÃ­nimo que a funÃ§Ã£o conhece. O tipo real (ex: Produto) pode ter outros mÃ©todos, mas eles ficam inacessÃ­veis via dyn Crud.

**âš ï¸ Importante:**
>VocÃª nÃ£o pode armazenar tipos diferentes diretamente num Vec<Animal>  
>Mas pode fazer isso com Vec<Box<dyn Animal>>

```rust
let animais: Vec<Box<dyn Animal>> = vec![
    Box::new(Gato),
    Box::new(Cachorro),
];
```

**âœ… 2. O que Ã© Box?**  
>Box<T> Ã© um ponteiro inteligente que aloca um valor no heap em vez da stack.  
>**ğŸ§  Para que serve?**
> - Armazenar dados grandes ou de tamanho desconhecido em tempo de compilaÃ§Ã£o
> - Armazenar tipos dinÃ¢micos, como Box<dyn Trait>
> - Mover valores sem copiar
> - Evitar recursÃ£o infinita em structs recursivas (como em Ã¡rvores)


ğŸ§ª Exemplo simples:
```rust 

let valor = Box::new(42);      // Aloca 42 no heap
println!("{}", *valor);        // Desreferencia

//Exemplo com Trait, Sem Box:
let lista: Vec<dyn Crud>;  // âŒ ERRO: tamanho desconhecido

//Com Box:

let lista: Vec<Box<dyn Crud>> = vec![
    Box::new(Produto { nome: "X".to_string(), preco: 1.0 }),
    Box::new(Cliente { nome: "Y".to_string(), email: "x@y.com" }),
];

```

> ğŸ§  Por quÃª?
dyn Trait tem tamanho indefinido, mas Box<dyn Trait> tem tamanho fixo (um ponteiro) â€” e isso resolve o problema de armazenamento.

**âœ… 1. ComparaÃ§Ã£o com JavaScript:**

> Passar &dyn Trait para uma funÃ§Ã£o em Rust Ã© como passar um objeto com mÃ©todos para uma funÃ§Ã£o em JavaScript:
```js
function executar(obj) {
  obj.read();
  obj.update();
}
```
> Em Rust: executar_crud(entidade: &dyn Crud) faz isso com seguranÃ§a de tipo e desempenho melhor

---
**âœ… 2. DiferenÃ§a entre stack e heap:**  

**Stack:** memÃ³ria local da thread atual, rÃ¡pida, com tamanho fixo, usada para dados pequenos e temporÃ¡rios (como nÃºmeros, referÃªncias, structs pequenas).

**Heap:** memÃ³ria globalmente acessÃ­vel, usada para dados grandes ou de tempo de vida indefinido (como String, Vec, Box, etc).

**Resumindo:**  
**Stack** rÃ¡pida, local, previsÃ­vel  
**Heap** â†’ flexÃ­vel, compartilhÃ¡vel, mais lenta (mas necessÃ¡ria em muitos casos)

**âœ… 2. O programador deve se preocupar com stack/heap?**

> Sim, mas com muito menos dor de cabeÃ§a.  
> Rust cuida da alocaÃ§Ã£o e liberaÃ§Ã£o automaticamente, mas vocÃª deve entender os princÃ­pios para escrever cÃ³digo eficiente e sem erros de propriedade.

**âœ… Exemplo prÃ¡tico: leitura de JSON (ex: array de objetos)**  

>Quando vocÃª lÃª o retorno de uma API com serde_json e transforma em um Vec<Objeto>, o Rust: 
>Aloca o vetor (Vec) no stack  
>Aloca os dados (cada Objeto) no heap  

**âœ… Isso Ã© automÃ¡tico, vocÃª nÃ£o precisa gerenciar manualmente.**

```rust
#[derive(Deserialize)]
struct Produto {
    nome: String,
    preco: f64,
}

let json = r#"[{"nome":"Caneta","preco":2.5}]"#;
let produtos: Vec<Produto> = serde_json::from_str(json)?; // Alocado corretamente
```
> **A String e o Vec sÃ£o heap por natureza.**  
> A variÃ¡vel produtos (ponteiro + tamanho + capacidade) vive na stack.  
> O conteÃºdo (cada Produto) vai para o heap.

---

