## Entendendo Option e Result com analogia e aplica√ß√£o pr√°tica
--- 

‚úÖ O que √© Option

Option<T> representa um valor que pode ou n√£o existir.
 - Some(valor) ‚Üí Existe um valor
 - None ‚Üí N√£o existe (sem valor)

üß† Analogia (JavaScript)

```js
function buscar() {
  return objeto || null;
}

```

ü¶Ä Em Rust:
```rust
fn buscar() -> Option<String> {
    Some("Valor".to_string()) // ou None
}
‚úÖ O que √© Result
Result<T, E> representa um sucesso ou erro ao tentar realizar uma a√ß√£o.

Ok(valor) ‚Üí Tudo certo

Err(erro) ‚Üí Ocorreu algum erro


```

üß† Analogia (JavaScript)
```js
try {
  return resultado;
} catch (err) {
  return "Erro";
}

```

ü¶Ä Em Rust:
```rust
fn processar() -> Result<i32, String> {
    Ok(42) // ou Err("falha".to_string())
}
```
**‚úÖ Exemplo pr√°tico em uma API REST**

> Simulando um controller que busca dados em um model, com base no id.  
> Se encontrar, retorna Option e converte para Result para formatar resposta RESTful.

**üß± Structs e Mock Model**

```rust
#[derive(Debug, Clone)]
struct Produto {
    id: u32,
    nome: String,
}

fn buscar_produto_por_id(id: u32) -> Option<Produto> {
    let produtos = vec![
        Produto { id: 1, nome: "Notebook".to_string() },
        Produto { id: 2, nome: "Teclado".to_string() },
    ];

    produtos.into_iter().find(|p| p.id == id)
}
```

**üß© Controller simulando resposta de uma API**
```rust
use std::collections::HashMap;

fn controller_buscar_produto(id: u32) -> Result<HashMap<&'static str, String>, (u16, String)> {
    match buscar_produto_por_id(id) {
        Some(produto) => {
            let mut resposta = HashMap::new();
            resposta.insert("status", "200".to_string());
            resposta.insert("ok", "true".to_string());
            resposta.insert("result", format!("Produto: {}", produto.nome));
            Ok(resposta)
        },
        None => Err((404, "Produto n√£o encontrado".to_string())),
    }
}
```

**üß™ Exemplo de chamada no main**
```rust
fn main() {
    match controller_buscar_produto(1) {
        Ok(json) => println!("‚úÖ Sucesso: {:?}", json),
        Err((status, msg)) => println!("‚ùå Erro {}: {}", status, msg),
    }

    match controller_buscar_produto(99) {
        Ok(json) => println!("‚úÖ Sucesso: {:?}", json),
        Err((status, msg)) => println!("‚ùå Erro {}: {}", status, msg),
    }
}
```

**üß© Sa√≠da esperada:**
```css
‚úÖ Sucesso: {"status": "200", "ok": "true", "result": "Produto: Notebook"}
‚ùå Erro 404: Produto n√£o encontrado
```

Vamos ver como o operador `?` pode simplificar o uso de Result e Option, tornando o c√≥digo mais limpo e leg√≠vel, principalmente em APIs e l√≥gicas de neg√≥cio.

**‚úÖ Usando o Operador ? com Result e Option**

**üß† O que o operador ? faz?**

- Se o valor for Ok (ou Some), ele extrai o valor e continua a execu√ß√£o.
- Se for Err (ou None), ele retorna imediatamente da fun√ß√£o com o erro.
- √â como um "atalho para erro".
- Ele evita muitos match aninhados ou if let.

**üî∏ Exemplo pr√°tico com Result usando ?**

**üß± Model**

```rust
#[derive(Debug)]
struct Produto {
    id: u32,
    nome: String,
}

fn buscar_produto(id: u32) -> Option<Produto> {
    let produtos = vec![
        Produto { id: 1, nome: "Mouse".into() },
        Produto { id: 2, nome: "Teclado".into() },
    ];
    produtos.into_iter().find(|p| p.id == id)
}

fn verificar_estoque(id: u32) -> Result<u32, String> {
    if id == 1 {
        Ok(10) // Em estoque
    } else {
        Err("Produto sem estoque".into())
    }
}
```

**üîÅ Controller com ?**
```rust
fn controller_detalhes_produto(id: u32) -> Result<String, String> {
    let produto = buscar_produto(id).ok_or("Produto n√£o encontrado")?; // transforma Option em Result
    let estoque = verificar_estoque(produto.id)?; // se Err, j√° retorna daqui

    Ok(format!(
        "Produto: {}, Estoque: {} unidades",
        produto.nome, estoque
    ))
}
```

**üß™ Uso:**
```rust
fn main() {
    match controller_detalhes_produto(1) {
        Ok(msg) => println!("‚úÖ {}", msg),
        Err(e) => println!("‚ùå Erro: {}", e),
    }

    match controller_detalhes_produto(99) {
        Ok(msg) => println!("‚úÖ {}", msg),
        Err(e) => println!("‚ùå Erro: {}", e),
    }
}
```

**üîç Sa√≠da:**
```yaml
‚úÖ Produto: Mouse, Estoque: 10 unidades
‚ùå Erro: Produto n√£o encontrado
```
üìå Observa√ß√µes:

- `?` funciona apenas em fun√ß√µes que tamb√©m retornam `Result` ou `Option`.
- Para usar `?` com `Option`, √© comum converter com `.ok_or("mensagem")` para `Result`.


---




**‚úÖ Tratamentos de erro mais comuns no dia a dia**

**1Ô∏è‚É£ Result<T, E> com ?**

Situa√ß√£o: opera√ß√µes que podem falhar, como:

- Leitura de arquivo
- Requisi√ß√µes HTTP
- Deserializa√ß√£o de JSON


```rust
let response = reqwest::get(url).await?.json::<MinhaResposta>().await?;
```
- ‚úÖ Motivo: o ? simplifica o c√≥digo e j√° propaga o erro.
- üîí Bom para fun√ß√µes que j√° retornam Result, como handlers de API.

**2Ô∏è‚É£ Option<T> com ok_or(...) ou ok_or_else(...)**

Situa√ß√£o: Falta de campo em JSON ou valores opcionais.

```rust
let nome = json.get("nome").and_then(|v| v.as_str()).ok_or("Nome ausente")?;

```
- ‚úÖ Motivo: transforma Option em Result com mensagem de erro clara.
- üß† √ötil ao validar dados antes de salvar no banco, por exemplo.

**3Ô∏è‚É£ match em cima de Result ou Option**

Situa√ß√£o: controle de fluxo mais detalhado, logs, fallback.

```rust
match resultado {
    Ok(dados) => processar(dados),
    Err(e) => log::warn!("Erro na API: {}", e),
}
```
- ‚úÖ Motivo: permite resposta customizada, como um HTTP 400 ou 500.

**4Ô∏è‚É£ unwrap_or, unwrap_or_else, map_or, map_or_else**

Situa√ß√£o: valores opcionais com padr√£o ou l√≥gica alternativa.


```rust
let idade = json.get("idade").and_then(|v| v.as_u64()).unwrap_or(0);
```
- ‚úÖ Motivo: muito √∫til para JSON parcial ou campos opcionais.
- üß† Use s√≥ quando faz sentido continuar com valor padr√£o.

**5Ô∏è‚É£ thiserror ou anyhow (crates para erros elegantes)**

Situa√ß√£o: projetos m√©dios, com m√∫ltiplas fontes de erro.

```rust
#[derive(thiserror::Error, Debug)]
pub enum MeuErro {
    #[error("Erro na API: {0}")]
    Api(String),
    #[error("Erro de JSON")]
    Json(#[from] serde_json::Error),
}
```
- ‚úÖ Motivo: melhora a legibilidade, evita repeti√ß√µes, compat√≠vel com ?.

**üß≠ Dica geral por contexto**

| Contexto                      | Recomendado                                         |
| ----------------------------- | --------------------------------------------------- |
| Falta de campo no JSON        | `Option + ok_or`                                    |
| Erro ao chamar API externa    | `Result + match` ou `?` + enum personalizado        |
| L√≥gica de fallback            | `unwrap_or`, `unwrap_or_else`                       |
| Fun√ß√µes encadeadas            | `?`                                                 |
| Erros variados no mesmo fluxo | `enum + thiserror`                                  |
| Sistemas REST ou GraphQL      | `Result<T, ApiError>` com c√≥digo/status customizado |


---


**Exemplo pr√°tico completo simulando uma API que:**

- Recebe JSON com campos opcionais
- Valida campos obrigat√≥rios
- Faz uma chamada externa (simulada)
- Usa ?, Option, ok_or, thiserror e retorna um Result


```rust
use serde::Deserialize;
use thiserror::Error;

// Dados recebidos no JSON
#[derive(Deserialize)]
struct PedidoInput {
    cliente: Option<String>,
    produto_id: Option<u32>,
    quantidade: Option<u32>,
}

// Erros poss√≠veis da API
#[derive(Debug, Error)]
enum ApiErro {
    #[error("Campo obrigat√≥rio ausente: {0}")]
    CampoAusente(&'static str),

    #[error("Erro de rede")]
    Rede(#[from] reqwest::Error),

    #[error("Erro inesperado")]
    Outro(String),
}

// Simula√ß√£o de chamada externa (ex: estoque)
async fn verificar_estoque(produto_id: u32) -> Result<bool, reqwest::Error> {
    // Aqui seria: reqwest::get(...).await?.json().await
    Ok(produto_id != 0) // falso se id = 0
}

// Handler da rota POST /pedidos
async fn criar_pedido(body: PedidoInput) -> Result<String, ApiErro> {
    // Valida√ß√µes
    let cliente = body.cliente.ok_or(ApiErro::CampoAusente("cliente"))?;
    let produto_id = body.produto_id.ok_or(ApiErro::CampoAusente("produto_id"))?;
    let quantidade = body.quantidade.unwrap_or(1); // opcional com padr√£o

    // Verifica se produto est√° dispon√≠vel (chamada externa)
    let disponivel = verificar_estoque(produto_id).await?;
    if !disponivel {
        return Err(ApiErro::Outro("Produto sem estoque".to_string()));
    }

    Ok(format!(
        "Pedido criado: cliente={}, produto={}, quantidade={}",
        cliente, produto_id, quantidade
    ))
}
```

**‚úÖ Como esse exemplo usa os conceitos:**

| Conceito Rust        | Onde aparece                                         |
| -------------------- | ---------------------------------------------------- |
| `Option<T>`          | Campos do JSON (`Option<String>`, etc.)              |
| `ok_or(...)`         | Transforma `Option` em `Result` com erro             |
| `Result<T, E>`       | Fluxo principal da fun√ß√£o `criar_pedido`             |
| `?`                  | Propaga erro da fun√ß√£o externa (`verificar_estoque`) |
| `enum` + `thiserror` | Cria√ß√£o de erros customizados (`ApiErro`)            |
| `unwrap_or(...)`     | Usa valor padr√£o se `quantidade` for ausente         |

