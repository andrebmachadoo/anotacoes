## Controle de Fluxo
---

**Condicional if / else**
```rust
let idade = 18;

if idade >= 18 {
    println!("Você é maior de idade.");
} else {
    println!("Você é menor de idade.");
}

// Condicional com else if
let nota = 7.5;

if nota >= 9.0 {
    println!("Excelente");
} else if nota >= 7.0 {
    println!("Bom");
} else {
    println!("Precisa melhorar");
}

```
**match (semelhante ao switch de outras linguagens)**

```rust
let dia = 3;

match dia {
    1 => println!("Segunda-feira"),
    2 => println!("Terça-feira"),
    3 => println!("Quarta-feira"),
    4 => println!("Quinta-feira"),
    5 => println!("Sexta-feira"),
    6 | 7 => println!("Fim de semana"),
    _ => println!("Dia inválido"),
}

```

**Loop while**

```rust
let mut contador = 0;

while contador < 3 {
    println!("Contador: {}", contador);
    contador += 1;
}

```
**Loop for com range**

```rust
for i in 1..5 {
    // Vai de 1 até 4 (exclusivo no final)
    println!("i: {}", i);
}

```

**Loop infinito com break**

```rust

let mut x = 0;

loop {
    if x == 3 {
        break; // Sai do loop quando x == 3
    }
    println!("x: {}", x);
    x += 1;
}

```

**continue para pular uma iteração**
```rust
for n in 0..5 {
    if n % 2 == 0 {
        continue; // pula os pares
    }
    println!("Ímpar: {}", n);
}

```

**Loops percorrendo vetor de structs(Array de objetos)**

```rust

// Definindo uma struct Pessoa
struct Pessoa {
    nome: String,
    idade: u32,
}

fn main() {
    // Criando um vetor de pessoas
    let pessoas = vec![
        Pessoa { nome: String::from("Ana"), idade: 25 },
        Pessoa { nome: String::from("Bruno"), idade: 30 },
        Pessoa { nome: String::from("Carla"), idade: 22 },
    ];

    // for pessoa in &pessoas itera com referência(&), sem mover o vetor
    for pessoa in &pessoas {
        println!("Nome: {}, Idade: {}", pessoa.nome, pessoa.idade);
    }

    /** 
        Usando for com índice (enumerate)
        enumerate() fornece o índice junto com o item.
        .iter() é necessário para evitar mover os dados se você quiser reutilizar depois.
    */ 
    for (i, pessoa) in pessoas.iter().enumerate() {
        println!("Pessoa {}: {} ({})", i, pessoa.nome, pessoa.idade);
    }

    // Usando while para percorrer manualmente (, acessando pelo índice)
    let mut i = 0;
    while i < pessoas.len() {
        let p = &pessoas[i];
        println!("{} tem {} anos", p.nome, p.idade);
        i += 1;
    }

    /**
    Após into_iter(), o vetor original não estará mais acessível porque os dados foram movidos.
    */
    for pessoa in pessoas.into_iter() {
        println!("{} tem {} anos", pessoa.nome, pessoa.idade);
    }

    /**
    (percorre com referência mutável – permite modificar os itens)
    Ou seja para utilizar o iter_mut a variavel pessoas deve ser
    declarada como mut. Ex: let mut pessoas = vec![...]
     */
    for pessoa in pessoas.iter_mut() {
        pessoa.idade += 1; // exemplo: envelhecer 1 ano
        println!("{} agora tem {} anos", pessoa.nome, pessoa.idade);
    }

}

```
**Essas duas formas são úteis conforme a necessidade:**

 - **into_iter()** para consumir (ex: salvar em outro lugar, enviar para API, etc.)
 - **iter_mut()** para editar os itens direto no vetor.

> Essas variações (iter(), iter_mut(), into_iter()) existem por causa das regras de ownership e borrowing do Rust. Aqui está um resumo direto:


🔍 **Por que into_iter() move os valores, mesmo sem modificar?**
Em Rust, o uso de into_iter() não depende se você modifica ou não os dados, mas se você precisa da posse (ownership) deles.
Mesmo que só vá imprimir, o uso de pessoa.nome (sem &) dentro do loop move o campo nome também, o que exige que pessoa seja dono do valor — e isso só acontece com into_iter().

🧠 **Quando usar into_iter() então?**
Use quando você:

 - Vai consumir os itens, por exemplo:
 - Mover para outra variável/coleção
 - Devolver ou transformar em outro tipo
 - Remover ou extrair partes do dado (como nome)
 - Não precisa mais do vetor original

```rust
let nomes: Vec<String> = pessoas.into_iter().map(|p| p.nome).collect();

```

>Aqui, p.nome é movido para um novo vetor. pessoas deixa de existir após isso.

☑️ **Quando não usar into_iter()?**
Se você só quer:

 - Ler os dados (iter())
 - Modificar in-place (iter_mut())
 - Manter o vetor utilizável depois
 - Então use iter() ou iter_mut():

```rust
for pessoa in &pessoas {
    println!("{}", pessoa.nome); // sem mover nada
}
```
---
