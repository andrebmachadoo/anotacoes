## Controle de Fluxo
---

**Condicional if / else**
```rust
let idade = 18;

if idade >= 18 {
    println!("VocÃª Ã© maior de idade.");
} else {
    println!("VocÃª Ã© menor de idade.");
}

// Condicional com else if
let nota = 7.5;

if nota >= 9.0 {
    println!("Excelente");
} else if nota >= 7.0 {
    println!("Bom");
} else {
    println!("Precisa melhorar");
}

```
**match (semelhante ao switch de outras linguagens)**

```rust
let dia = 3;

match dia {
    1 => println!("Segunda-feira"),
    2 => println!("TerÃ§a-feira"),
    3 => println!("Quarta-feira"),
    4 => println!("Quinta-feira"),
    5 => println!("Sexta-feira"),
    6 | 7 => println!("Fim de semana"),
    _ => println!("Dia invÃ¡lido"),
}

```

**Loop while**

```rust
let mut contador = 0;

while contador < 3 {
    println!("Contador: {}", contador);
    contador += 1;
}

```
**Loop for com range**

```rust
for i in 1..5 {
    // Vai de 1 atÃ© 4 (exclusivo no final)
    println!("i: {}", i);
}

```

**Loop infinito com break**

```rust

let mut x = 0;

loop {
    if x == 3 {
        break; // Sai do loop quando x == 3
    }
    println!("x: {}", x);
    x += 1;
}

```

**continue para pular uma iteraÃ§Ã£o**
```rust
for n in 0..5 {
    if n % 2 == 0 {
        continue; // pula os pares
    }
    println!("Ãmpar: {}", n);
}

```

**Loops percorrendo vetor de structs(Array de objetos)**

```rust

// Definindo uma struct Pessoa
struct Pessoa {
    nome: String,
    idade: u32,
}

fn main() {
    // Criando um vetor de pessoas
    let pessoas = vec![
        Pessoa { nome: String::from("Ana"), idade: 25 },
        Pessoa { nome: String::from("Bruno"), idade: 30 },
        Pessoa { nome: String::from("Carla"), idade: 22 },
    ];

    // for pessoa in &pessoas itera com referÃªncia(&), sem mover o vetor
    for pessoa in &pessoas {
        println!("Nome: {}, Idade: {}", pessoa.nome, pessoa.idade);
    }

    /** 
        Usando for com Ã­ndice (enumerate)
        enumerate() fornece o Ã­ndice junto com o item.
        .iter() Ã© necessÃ¡rio para evitar mover os dados se vocÃª quiser reutilizar depois.
    */ 
    for (i, pessoa) in pessoas.iter().enumerate() {
        println!("Pessoa {}: {} ({})", i, pessoa.nome, pessoa.idade);
    }

    // Usando while para percorrer manualmente (, acessando pelo Ã­ndice)
    let mut i = 0;
    while i < pessoas.len() {
        let p = &pessoas[i];
        println!("{} tem {} anos", p.nome, p.idade);
        i += 1;
    }

    /**
    ApÃ³s into_iter(), o vetor original nÃ£o estarÃ¡ mais acessÃ­vel porque os dados foram movidos.
    */
    for pessoa in pessoas.into_iter() {
        println!("{} tem {} anos", pessoa.nome, pessoa.idade);
    }

    /**
    (percorre com referÃªncia mutÃ¡vel â€“ permite modificar os itens)
    Ou seja para utilizar o iter_mut a variavel pessoas deve ser
    declarada como mut. Ex: let mut pessoas = vec![...]
     */
    for pessoa in pessoas.iter_mut() {
        pessoa.idade += 1; // exemplo: envelhecer 1 ano
        println!("{} agora tem {} anos", pessoa.nome, pessoa.idade);
    }

}

```
**Essas duas formas sÃ£o Ãºteis conforme a necessidade:**

 - **into_iter()** para consumir (ex: salvar em outro lugar, enviar para API, etc.)
 - **iter_mut()** para editar os itens direto no vetor.

> Essas variaÃ§Ãµes (iter(), iter_mut(), into_iter()) existem por causa das regras de ownership e borrowing do Rust. Aqui estÃ¡ um resumo direto:


ğŸ” **Por que into_iter() move os valores, mesmo sem modificar?**
Em Rust, o uso de into_iter() nÃ£o depende se vocÃª modifica ou nÃ£o os dados, mas se vocÃª precisa da posse (ownership) deles.
Mesmo que sÃ³ vÃ¡ imprimir, o uso de pessoa.nome (sem &) dentro do loop move o campo nome tambÃ©m, o que exige que pessoa seja dono do valor â€” e isso sÃ³ acontece com into_iter().

ğŸ§  **Quando usar into_iter() entÃ£o?**
Use quando vocÃª:

 - Vai consumir os itens, por exemplo:
 - Mover para outra variÃ¡vel/coleÃ§Ã£o
 - Devolver ou transformar em outro tipo
 - Remover ou extrair partes do dado (como nome)
 - NÃ£o precisa mais do vetor original

```rust
let nomes: Vec<String> = pessoas.into_iter().map(|p| p.nome).collect();

```

>Aqui, p.nome Ã© movido para um novo vetor. pessoas deixa de existir apÃ³s isso.

â˜‘ï¸ **Quando nÃ£o usar into_iter()?**
Se vocÃª sÃ³ quer:

 - Ler os dados (iter())
 - Modificar in-place (iter_mut())
 - Manter o vetor utilizÃ¡vel depois
 - EntÃ£o use iter() ou iter_mut():

```rust
for pessoa in &pessoas {
    println!("{}", pessoa.nome); // sem mover nada
}
```
---
